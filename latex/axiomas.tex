En esta pagina, y por conveniencia, se listan todos los axiomas y proposiciones auxiliares requeridos para formalizar los invariantes de representación y las funciones de abstracción. Previamente se presentan los renombres de los tipos usados.

\begin{DoxyParagraph}{Renombres de tipos}

\end{DoxyParagraph}

\begin{DoxyItemize}
\item Node es tupla(child\+: arreglo\mbox{[}2\mbox{]} de puntero(\+Node), parent\+: puntero(\+Node), color\+: Color, value\+: Value)
\item Value es Maybe(value\+\_\+type)
\item value\+\_\+type es tupla(clave\+: Key, significado\+: Meaning)
\end{DoxyItemize}

El T\+AD Maybe( $\alpha$) representa un tipo $\alpha$ extendido con un valor nulo. En otras palabras, el T\+AD Maybe se puede usar para representar los valores de los nodos, donde el nodo cabecera no tiene valor y los nodos internos sí tienen valor. (Esto independientemente de si se implementa con herencia o con un puntero o de otra forma.) Tiene dos observadores\+:
\begin{DoxyItemize}
\item nothing?(x)\+: que indica si x tiene un valor nulo, y
\item data(x)\+: que devuelve el valor de x, suponiendo que no es inválido.
\end{DoxyItemize}

La especificación de este T\+AD queda como ejercicio (no obligatorio).\hypertarget{axiomas_sec-Axiomas}{}\subsection{Axiomas y proposiciones auxiliares}\label{axiomas_sec-Axiomas}
En esta sección se deben incluir todos los axiomas y proposiciones auxiliares que se usen para describir los invariantes de representación, las funciones de abstracción, las precondiciones y las postcondiciones.

\begin{DoxyRemark}{Comentarios}
Recordar incluir un alias en el archivo doxyfile a fin de poder referenciar automaticamente a cada axioma desde las otras páginas.
\end{DoxyRemark}
Se muestran algunos ejemplos a continuación.

\begin{DoxyParagraph}{es\+Diccionario?}
Retorna true si la secuencia representa un diccionario

es\+Diccionario?\+: secu(tupla( $\alpha$, $\beta$)) $\to$ bool~\newline
es\+Diccionario?(s) $\equiv$ sin\+Repetidos?(\href{axiomas.html#primeros}{\tt primeros}(s)) 
\end{DoxyParagraph}


\begin{DoxyParagraph}{primeros}
Proyecta las primeras componentes de una secuencia de pares

primeros\+: secu(tupla( $\alpha$, $\beta$)) $\to$ secu( $\alpha$)~\newline
primeros(s) $\equiv$ {\bfseries if} vacia?(s) {\bfseries then} $<$$>$ {\bfseries else} $\pi_1$(prim(s)) $\bullet$ \href{axiomas.html#primeros}{\tt primeros}(fin(s)) {\bfseries fi} 
\end{DoxyParagraph}


\begin{DoxyParagraph}{raiz}
Devuelve un puntero a la raíz del árbol representado por m.

raiz\+: map $\to$ puntero(nodo) ~\newline
raiz(m) $\equiv$ m.\+header-\/$>$parent


\end{DoxyParagraph}
\begin{DoxyParagraph}{es\+Arbol}
Proposición que dice si una estructura representada con punteros a nodo se corresponde efectivamente con un árbol binario finito. La primera proposición asegura que el árbol termina, mientras que la segunda afirma que ningún nodo es hijo de dos nodos distintos (es decir, no hay ciclos).

es\+Arbol\+: puntero(\+Node) $\to$ bool ~\newline
es\+Arbol(p) $\equiv$ true $\Leftrightarrow$ ( $\exists$ k\+:nat) (p,k) $=_{\rm obs}$ (p,k+1) $\land$ ((p,k))


\end{DoxyParagraph}
\begin{DoxyParagraph}{arbolK}
Devuelve los primeros k niveles del árbol binario de punteros cuya raíz es apuntada por p.

arbolK\+: puntero(\+Node) $\times$ nat $\to$ ab(puntero(\+Node)) ~\newline
arbol\+K(p,k) $\equiv$ ~\newline
 {\bfseries if} p = nullptr {\bfseries then} ~\newline
 nil ~\newline
 {\bfseries else} ~\newline
{\bfseries if} k = 0 {\bfseries then} ab(nil,p,nil) {\bfseries else} ab((p-\/$>$child\mbox{[}0\mbox{]},k-\/1),p,(p-\/$>$child\mbox{[}1\mbox{]},k-\/1)) {\bfseries fi} ~\newline
 {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{sin\+Repetidos\+AB}
Dice si un árbol binario tiene o no elementos repetidos.

sin\+Repetidos\+AB\+: ab( $\alpha$) $\to$ bool ~\newline
sin\+Repetidos\+A\+B(a) $\equiv$ {\bfseries if} a = nil {\bfseries then} true {\bfseries else} $\lnot$ ((raíz(a),izq(a)) $\lor$ (raíz(a),der(a))) $\land$ (izq(a)) $\land$ (der(a)) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{pertenece\+AB}
Dice si un elemento está o no en un árbol binario.

pertenece\+AB\+:  $\alpha$ $\times$ ab( $\alpha$) $\to$ bool ~\newline
pertenece\+A\+B(e,a) $\equiv$ {\bfseries if} a = nil {\bfseries then} false {\bfseries else} raíz(a) = e $\lor$ (e,izq(a)) $\lor$ (e,der(a)) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{es\+A\+B\+B\+Dicc}
Dice si el árbol binario que tiene a p como raíz es un A\+BB sin claves repetidas. Para asegurar esto último, las funciones auxiliares  y  hacen comparaciones {\itshape estrictas}.

es\+A\+B\+B\+Dicc\+: puntero(\+Node) p $\to$ bool \{(p)\} ~\newline
es\+A\+B\+B\+Dicc(p) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} true {\bfseries else} (p-\/$>$child\mbox{[}0\mbox{]},p-\/$>$value.\+first) $\land$ (p-\/$>$child\mbox{[}1\mbox{]},p-\/$>$value.\+first) $\land$ (p-\/$>$child\mbox{[}0\mbox{]}) $\land$ (p-\/$>$child\mbox{[}1\mbox{]}) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{todos\+Menores}
Dice si todas las claves del árbol binario a cuya raíz apunta p son estrictamentente menores a e.

todos\+Menores\+: puntero(\+Node) p $\times$ Key $\to$ bool \{(p)\} ~\newline
todos\+Menores(p,e) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} true {\bfseries else} p-\/$>$value.\+first $<$ e $\land$ (p-\/$>$child\mbox{[}0\mbox{]},e) $\land$ (p-\/$>$child\mbox{[}1\mbox{]},e) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{todos\+Mayores}
Dice si todas las claves del árbol binario a cuya raíz apunta p son estrictamentente mayores a e.

todos\+Mayores\+: puntero(\+Node) p $\times$ Key $\to$ bool \{(p)\} ~\newline
todos\+Mayores(p,e) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} true {\bfseries else} p-\/$>$value.\+first $>$ e $\land$ (p-\/$>$child\mbox{[}0\mbox{]},e) $\land$ (p-\/$>$child\mbox{[}1\mbox{]},e) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{es\+R\+B\+Tree}
Dice si el árbol binario a cuya raíz apunta p cumple el invariante de red-\/black tree (adaptado a nuestra implementación con hojas nullptr)\+: todos los nodos son o rojos o negros, la raíz es negra, todos los nodos rojos tienen sólo hijos negros y todas las ramas desde cualquier nodo interno tienen la misma cantidad de nodos negros.

es\+R\+B\+Tree\+: puntero(\+Node) p $\to$ bool \{(p)\} ~\newline
(p) $\equiv$ p = nullptr $\lor_{\rm L}$ ((p) $\land$ p-\/$>$color = Black $\land$ (p) $\land$ (p) )


\end{DoxyParagraph}
\begin{DoxyParagraph}{colores\+Validos}
Dice si el árbol binario a cuya raíz apunta p sólo tiene nodos negros y rojos.

colores\+Validos\+: puntero(\+Node) p $\to$ bool \{(p)\} ~\newline
colores\+Validos(p) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} true {\bfseries else} p-\/$>$color  Header $\land$ (p-\/$>$child\mbox{[}0\mbox{]}) $\land$ (p-\/$>$child\mbox{[}1\mbox{]}) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{misma\+Cant\+Negros}
Dice si todas las ramas que salen desde cualquier nodo del árbol binario a cuya raíz apunta tienen la misma cantidad de nodos negros. Observar que, como estamos pidiendo que los hijos de p cumplan este axioma, alcanza con verificar que la cantidad de nodos negros de una rama (en particular la extrema izquierda) es la misma para los dos hijos, y de esa forma aseguramos que se cumple recursivamente misma\+Cant\+Negros.

misma\+Cant\+Negros\+: puntero(\+Node) p $\to$ bool \{(p)\} ~\newline
misma\+Cant\+Negros(p) $\equiv$ p = nullptr $\lor_{\rm L}$ ( (p-\/$>$child\mbox{[}0\mbox{]}) = (p-\/$>$child\mbox{[}1\mbox{]}) $\land$ (p-\/$>$child\mbox{[}0\mbox{]}) $\land$ (p-\/$>$child\mbox{[}1\mbox{]}) )


\end{DoxyParagraph}
\begin{DoxyParagraph}{cant\+Negros}
Devuelve la cantidad de nodos negros de la rama extrema izquierda del árbol binario a cuya raíz apunta p. Por lo explicado anteriormente, esta función sirve para computar misma\+Cant\+Negros.

cant\+Negros\+: puntero(\+Node) p $\to$ nat \{(p)\} ~\newline
cant\+Negros(p) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} 0 {\bfseries else} (p-\/$>$child\mbox{[}0\mbox{]}) $+$ ({\bfseries if} p-\/$>$color = Black {\bfseries then} 1 {\bfseries else} 0 {\bfseries fi} ) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{rojo\+Implica\+Hijos\+Negros}
Dice si todos los nodos rojos del árbol binario a cuya raíz apunta p tienen únicamente hijos negros.

rojo\+Implica\+Hijos\+Negros\+: puntero(\+Node) p $\to$ bool \{(p)\} ~\newline
rojo\+Implica\+Hijos\+Negros(p) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} true {\bfseries else} p-\/$>$color = Red $\Rightarrow_{\rm L}$ ( (p-\/$>$child\mbox{[}0\mbox{]}) $\land$ (p-\/$>$child\mbox{[}1\mbox{]}) ) $\land$ (p-\/$>$child\mbox{[}0\mbox{]}) $\land$ (p-\/$>$child\mbox{[}1\mbox{]}) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{no\+Es\+Rojo}
Autoexplicativo.

no\+Es\+Rojo\+: puntero(\+Node) $\to$ bool ~\newline
no\+Es\+Rojo(p) $\equiv$ p  nullptr $\Rightarrow_{\rm L}$ p-\/$>$color  Red


\end{DoxyParagraph}
\begin{DoxyParagraph}{familia\+Correcta}
Función auxiliar de rep\+Map para verificar si el padre de la cabecera es efectivamente la raíz (y viceversa), si el hijo izquierdo de la cabecera es el menor elemento del árbol y si el hijo derecho de la cabecera es el mayor elemento del árbol.

familia\+Correcta\+: nodo $\times$ puntero(\+Node) p $\to$ bool \{p  nullptr\} ~\newline
familia\+Correcta(n,p) $\equiv$ n.\+child\mbox{[}0\mbox{]} = (p,0) $\land$ n.\+child\mbox{[}1\mbox{]} = (p,1) $\land$ n.\+parent = p $\land$ p-\/$>$parent = n


\end{DoxyParagraph}
\begin{DoxyParagraph}{get\+D\+Most}
Si d es 0, devuelve el nodo de extrema izquierda del árbol binario a cuya raíz apunta p; si es 1, devuelve el de extrema derecha.

get\+D\+Most\+: puntero(\+Node) p $\times$ nat d $\to$ puntero(\+Node) \{d $\leq$ 1 $\land$ p  nullptr $\land$ (p)\} ~\newline
get\+D\+Most(p,d) $\equiv$ {\bfseries if} p-\/$>$child\mbox{[}d\mbox{]} = nullptr {\bfseries then} p {\bfseries else} (p-\/$>$child\mbox{[}d\mbox{]},d) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{parent\+Correcto}
Dice si todos los nodos del árbol binario cuya raíz es apuntada por p tienen como padre al nodo que los tiene como hijos.

parent\+Correcto\+: puntero(\+Node) p $\to$ bool \{(p)\} parent\+Correcto(p) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} true {\bfseries else} (p-\/$>$child\mbox{[}0\mbox{]}  nullptr $\Rightarrow_{\rm L}$ p-\/$>$child\mbox{[}0\mbox{]}-\/$>$parent = p) $\land$ (p-\/$>$child\mbox{[}1\mbox{]}  nullptr $\Rightarrow_{\rm L}$ p-\/$>$child\mbox{[}1\mbox{]}-\/$>$parent = p) $\land$ parent\+Correcto(p-\/$>$child\mbox{[}0\mbox{]}) $\land$ parent\+Correcto(p-\/$>$child\mbox{[}0\mbox{]}) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{cant\+Nodos}
Devuelve la cantidad total de nodos del árbol binario a cuya raíz apunta p.

cant\+Nodos\+: puntero(\+Node) p $\to$ nat \{(p)\} ~\newline
cant\+Nodos(p) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} 0 {\bfseries else} suc((p-\/$>$child\mbox{[}0\mbox{]}) + (p-\/$>$child\mbox{[}1\mbox{]})) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{pertenece\+Clave\+A\+BB}
Dice si la clave c pertenece al árbol binario cuya raíz es apuntada por p.

pertenece\+Clave\+A\+BB\+: Key $\times$ puntero(\+Node) p $\to$ bool \{(p)\} ~\newline
pertenece\+Clave\+A\+B\+B(c,p) $\equiv$ {\bfseries if} p = nullptr {\bfseries then} false {\bfseries else} p-\/$>$value.\+first = c $\lor$ (c,p-\/$>$child\mbox{[}0\mbox{]}) $\lor$ (c,p-\/$>$child\mbox{[}1\mbox{]}) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{significado\+A\+BB}
Devuelve el significado de la clave c en el árbol binario cuya raíz es apuntada por p. Si hay dos tuplas en el árbol que tienen a c como primer componente, devuelve la que esté más a la izquierda, pero en este contexto sólo la llamaremos con árboles que son diccionarios y por lo tanto no tienen repetidos, así que esto no hace diferencia.

significado\+A\+BB\+: Key $\times$ puntero(\+Node) p $\to$ Meaning \{(p) $\land_{\rm L}$ (c,p)\} ~\newline
significado\+A\+B\+B(c,p) $\equiv$ {\bfseries if} p-\/$>$value.\+first = c {\bfseries then} p-\/$>$value.\+second {\bfseries else} ( {\bfseries if} (c,p-\/$>$child\mbox{[}0\mbox{]}) {\bfseries then} (c,p-\/$>$child\mbox{[}0\mbox{]}) {\bfseries else} (c,p-\/$>$child\mbox{[}1\mbox{]}) {\bfseries fi} ) {\bfseries fi} 


\end{DoxyParagraph}
\begin{DoxyParagraph}{el\+Header\+Esta\+Piola}
Función auxiliar para verificar la correctitud de  cuando el árbol representado es vacío. Responde a la estructura dada por la cátedra, en la que el constructor sin parámetros de map genera un árbol cuya cabecera tiene como hijo izquierdo y derecho a sí misma.

el\+Header\+Esta\+Piola\+: map $\to$ bool ~\newline
el\+Header\+Esta\+Piola(m) $\equiv$ m.\+header.\+parent = nullptr $\land$ m.\+header.\+child\mbox{[}0\mbox{]} = \&(m.\+header) $\land$ m.\+header.\+child\mbox{[}0\mbox{]} = \&(m.\+header) $\land$ m.\+count = 0


\end{DoxyParagraph}
\begin{DoxyParagraph}{parentK}
Función similar a , pero en vez de devolver los primeros k niveles de un árbol, devuelve el resultado de subir k veces por el nodo apuntado por p. Si se llega a un nodo que tiene como padre a nullptr, devuelve un puntero al último nodo que tenía como padre a un puntero no nulo.

parentK\+: puntero(\+Node) p $\times$ nat $\to$ puntero(\+Node) \{p  nullptr\} ~\newline
parent\+K(p,k) $\equiv$ {\bfseries if} p-\/$>$parent = nullptr {\bfseries then} p {\bfseries else} ({\bfseries if} k = 0 {\bfseries then} p {\bfseries else} parentK(p-\/$>$parent,k-\/1) {\bfseries fi} ) {\bfseries fi} 
\end{DoxyParagraph}
